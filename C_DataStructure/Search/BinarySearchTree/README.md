# Binary Search Tree

## Binary Search Tree란
  - **이진 탐색 트리 = 이진 트리 + 데이터 저장 규칙** : 즉, 이진 트리의 확장된 모델이다.
  - Heap구조는 중복된 값을 갖을 수 있지만, 이진 탐색 트리는 중복된 값을 가질 수 없다.
  - O(logN)의 시간복잡도를 갖지만, 만약 균형이 맞지 않는다면, O(N)의 시간복잡도를 갖을 수 있다.

## 데이터 저장 규칙
  - 노드에 저장된 **key는 유일**하다
  - **루트 노드의 키가 왼쪽 서브트리를 구성하는 어떠한 노드의 키보다 크다.**
  - **루트 노드의 키가 오른쪽 서브트리를 구성하는 어떠한 노드의 키보다 작다.**
  - **왼쪽, 오른쪽 서브트리도 이진탐색트리이다.**
  - **실질적 규칙 : 작으면 왼쪽으로, 크면 오른쪽으로!**

<img src ="https://user-images.githubusercontent.com/59442344/115131313-2553f400-a032-11eb-96f1-d8e0e7a46929.png" width=70% height=70%>

## 그럼 데이터를 어떻게 찾을까?
  - **찾는 키 값이, 현재 노드 키값보다 작다면 왼쪽으로 이동**한다
  - **찾는 키 값이, 현재 노드 키값보다 크다면 오른쪽으로 이동**한다
  - 결과적으로..
    - 길을 잃을 일이 없다!
    - 몇단계 지나지 않아서 탐색대상을 찾을 수 있다! 
  - 추가적으로..
    - **Tree구조 가장 작은 값은 계속 왼쪽으로 내려가면** 나온다.
    - **Tree구조 가장 큰 값은 계속 오른쪽으로 내려가면** 나온다.  
<img src ="https://user-images.githubusercontent.com/59442344/115131442-2174a180-a033-11eb-8521-969e4d8378a6.png" width=60% height=60%>

## 대략적인 ADT(기능 명세)
  - **(void) BST 초기화** : root 노드부터 추가하므로, root 노드 NULL
  - **(BSTData) BST Node 값 출력** : Node가 갖는 데이터 반환
  - **(void) BST Node 삽입**
    - 위치선정(+중복 key입력 무시)
    - 노드 생성
    - 노드 삽입(+root노드의 경우 고려)
  - **(BTNode \*) BST Node 탐색**
    - key 존재하면 노드 포인터값 반환
    - 없으면 NULL 반환
  - **(void) BST Node 삭제**
    - **삭제는 무조건 부모를 통해서! (pNode-cNode 짝의 중요성)** 
    - 가상 최상위 루트 노드 사용
    - 단말노드 삭제 : 그냥 트리에서 제거
    - 자식노드 1개노드 삭제 : "parent의 자식 == parent 자식의 자식"
    - 자식노드 2개노드 삭제 : parent값 == 우측 subtree중 가장 작은 값 -> "parent의 자식 == parent 자식의 자식"
    - 루트 노드 삭제 여부 고려 : cNode의 변경과, pRoot의 실체는 다른 것 -> cNode의 변경을 pRoot에 적용해줘야함

## Tree 자료구조 관련 Tip
  - Node 탐색에 따라, 말단까지 내려갈 수 있다.
  - **pNode(부모 노드) - cNode(자식/현재 노드) 관계**를 잘 이용하는 것을 고려해보자
    - BST 삭제 : pNode 자식 노드를 삭제, dNode(cNode)는 삭제할 Node 가리킴
    - BST 삽입 : pNode 자식 노드에 삽입, cNode는 NULL 가리킴
